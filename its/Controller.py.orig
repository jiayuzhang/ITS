from Entry import Entry
from Joint import Joint

class Controller(object):
    def __init__(self, _config, _canvas):
        self.canvas = _canvas
        self.entrys = []
        self.joints = []
        self.graph = None

        self.parseConfiguration(_config)
        self.initCanvas()

    def parseConfiguration(self,fileName):
        X,Y = 0,1
        inFile = open(fileName, "r")
        for line in inFile:
            line = line.strip("\n")
            if line == "#count":
                entryCnt = int(inFile.readline().strip("\n")[6:]) #entry=.. no pairs of entry connected
                jointCnt = int(inFile.readline().strip("\n")[6:]) #joint=.. at least one joint
<<<<<<< HEAD
                self.graph = [[False]*(entryCnt+jointCnt) for i in range(entryCnt+jointCnt)] #adj matrix
=======
                self.graph = [[0]*(entryCnt+jointCnt) for i in range(entryCnt+jointCnt)] #adj matrix
>>>>>>> 8441913cedc2eae1b0e13cea22ee0c168c66b8e8
            elif line == "#entry":
                for i in range(entryCnt):
                    coords = [int(token) for token in inFile.readline().strip("\n").split()]
                    self.entrys.append(Entry(coords[X],coords[Y],self.canvas))
            elif line == "#joint":
                for i in range(jointCnt):
                    coords = [int(token) for token in inFile.readline().strip("\n").split()]
                    self.joints.append(Joint(coords[X],coords[Y],self.canvas))
            elif line == "#entry_joint":
                for i in range(entryCnt):
                    tokens = inFile.readline().strip("\n").split()
                    for j in range(jointCnt):
                        self.graph[i][entryCnt+j] = self.graph[entryCnt+j][i] = True if int(tokens[j])==1 else False
            elif line == "#joint_joint":
                for i in range(jointCnt):
                    tokens = inFile.readline().strip("\n").split()
                    for j in range(jointCnt):
<<<<<<< HEAD
                        self.graph[entryCnt+i][entryCnt+j] = self.graph[entryCnt+j][entryCnt+i] = True if int(tokens[j])==1 else False
=======
                        if i != j:
                            self.graph[entryCnt+i][entryCnt+j] = self.graph[entryCnt+j][entryCnt+i] = self.calcDistance(self.joints[i],self.joints[j]) if int(tokens[j])==1 else -1

    def calcDistance(self,p1,p2):
        return int(sqrt(pow(p1.x-p2.x,2)+pow(p1.y-p2.y,2)))

>>>>>>> 8441913cedc2eae1b0e13cea22ee0c168c66b8e8

    def initCanvas(self):
        print("##########################")
        #for entry in self.entrys:
        #    entry.draw(self.canvas)
        #for joint in self.joints:
        #   joint.draw(self.canvas)

        entrySize = len(self.entrys)
        jointSize = len(self.joints)
        size = entrySize + jointSize
        print(size)
        for i in range(size):
            print(i)
            for j in range(i+1,size):
<<<<<<< HEAD
                print(j)
                print(self.graph[i][j])
                if self.graph[i][j]:
                    point1 = self.entrys[i] if i < entrySize else self.joints[i-entrySize]
                    point2 = self.entrys[j] if j < entrySize else self.joints[j-entrySize]
                    print(point1.x, point1.y)
                    print(point2.x, point2.y)
                    self.canvas.create_line(point1.x * 10, point2.y * 10, point2.x * 10, point2.y * 10,fill="black")
        
=======
                if self.graph[i][j] > 0:
                    point1,point2 = self.entrys[i] if i < entrySize else self.joints[i-entrySize],self.entrys[j] if j < entrySize else self.joints[j-entrySize]
                    self.canvas.create_line(point1.x,point2.y,point2.x,point2.y,fill="black")

>>>>>>> 8441913cedc2eae1b0e13cea22ee0c168c66b8e8
    
    def tick(self):
        #do logic on models
        #call each existing model draw method by passing canvas
        pass
